//! \file
//! \brief General type and macro definitions for VTKW library.

#ifdef VTKW_TYPES_H
#else
#define VTKW_TYPES_H

/* Check for availability of C99 features */
#if __STDC_VERSION__ < 199901L
#error "VTKW requires C99 compliant compiler"
#endif

#include <stdbool.h>

// For portability we use our own Int32 data type that consists of 32 bits and
// also an unsigned 16-bit type
#include <stdint.h>

//! Short-hand for a 32-bit signed integer type following C99 standard
typedef int32_t Int32;

//! Short-hand for a 16-bit unsigned integer type following C99 standard
typedef uint16_t Uint16;

//! Error code for developers' use
#define VTKW_DATABOX_ERROR -101

//! Error code for developers' use
#define VTKW_IO_ERROR -102

//! Data type describing type of file we are dealing with
typedef enum {

  //! default used for initialisation and error checking; corresponds to
  //! no type having been set
  NO_TYPE,

  //! signals that we are writing a <em>regular</em> .vtu file containing
  //! data
  VTU,

  //! signals that we are writing a .pvtu meta-file for Paraview
  PVTU

} vtkw_fileType;


//! Struct for bundling general information on simulation run and parameters

//! This struct is used to bundle general information on the simulation
//! performed by Terra, such as the mesh parameters, and also steering
//! parameters that influence the behaviour of VTKW. It is intended to be
//! filled by the VTKW_PREPARE() function.
typedef struct {

  //! Total number of MPI processes

  //! This field stores the total, i.e. in the communicator MPI_COMM_WORLD,
  //! number of MPI processes used in the current simulation run.
  Int32 nProcs;

  //! MPI rank of process executing

  //! This field stores the MPI rank of the process that is making use of
  //! VTKW. Since we do not perform any communication within VTKW this is
  //! only required for generation of file names.
  Int32 myRank;

  //! Number of subdomains associated to MPI process

  //! This field stores the number of subdomains associated to the currenlty
  //! executing MPI process. It corresponds to the value of <b>nd</b> in Terra
  //! and is required for knowing the number of <b>pieces</b> that must be
  //! written to the output file.
  Int32 nSubdoms;

  //! Number of spherical subdivisions of a subdomain edge

  //! This field stores the number of subdivisons along the edge of a
  //! complete diamond in the spherical part of the spatial discretisation.
  //! The value should be set to the value of <b>mt</b> in Terra.
  Int32 nSphIntervals;

  //! Number of subdivisions of the shell in radial direction

  //! This field stores the number of subdivisons in the radial part of the
  //! spatial discretisation. The value should be set to the value of
  //! <b>nr</b> in Terra.
  Int32 nRadIntervals;

  //! Pointer to 1D array with spherical node coordinates

  //! This field stores a pointer to a 1D array containing the cartesian
  //! coordinates (w.r.t. to Terra's discretisation of the unit sphere) of
  //! the nodes owned by this MPI process. Value corresponds to the starting
  //! memory address of the <b>xn</b> array from Terra's common block
  //! <b>mesh</b>.
  double *sphMesh;     

  //! Pointer to 1D array with radial layer coordinates

  //! This field stores a pointer to a 1D array containing the positions
  //! of the radial layers in Terra's mesh. Value corresponds to the starting
  //! memory address of the <b>rshl</b> array from Terra's common block
  //! <b>radl</b>.
  double *radii;

  //! Flag for toggling generation of .pvtu meta-file

  //! This field is used as a flag. If the value is true then the MPI process
  //! with rank 0 will generate a .pvtu meta-file that can be used to import
  //! all the different .vtu files generated by the individual MPI processes
  //! into Paraview.
  bool createPVTU;

  //! Flag for toggling diamond and rank information

  //! This field is used as a flag. If the value is true then VTKW will store
  //! for each cell of the mesh two scalar fields. One contains the unique
  //! diamond ID of the cell and the other the unique MPI rank of the process
  //! which is managing the subdomain to which the cell belongs.
  bool storeID;

  //! Flag for toggling data compression

  //! This field is used as a flag. If the value is true then VTKW will
  //! compress all data using the external zlib library.
  bool compress;

} vtkw_simSetup;


//! Type of data in a vtkw_dataBox

//! Data type for storing information on the type of data, e.g. scalar or
//! vectorial, that is at a current point being contained in a vtkw_dataBox
typedef enum {

  //! default used for initialisation and error checking; corresponds to
  //! no type having been set
  VTKW_NO_KIND,

  //! coordinates of mesh nodes
  VTKW_POINTS,
  
  //! types of cells of the mesh following VTK standard
  VTKW_CELL_TYPES,

  //! offset information, see VTK documentation
  VTKW_OFFSETS,

  //! connectivity of the mesh, i.e. the nodes to cell mapping
  VTKW_CONNECTIVITY,

  //! scalar field defined at the nodes of the mesh
  VTKW_POINT_DATA_SCALAR,

  //! 3D vector field defined at the nodes of the mesh
  VTKW_POINT_DATA_VECTOR,

  //! scalar field defined in cells of the mesh
  VTKW_CELL_DATA_SCALAR,

  //! 3D vector field defined in cells of the mesh
  VTKW_CELL_DATA_VECTOR,

  //! scalar field defined in cells of the mesh; stores rank of MPI process
  //! managing subdomain containing the cell; treated special, since this is
  //! encoded with unsigned integers
  VTKW_PROCESS_ID,

  //! scalar field defined in cells of the mesh; stores unique diamond ID of
  //! each mesh cell; treated special, since this is encoded with unsigned
  //! integers
  VTKW_DIAMOND_ID

} vtkw_dataKind;

#endif
